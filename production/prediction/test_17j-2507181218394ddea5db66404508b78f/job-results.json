{"assets": {"openEO.nc": {"bands": [{"name": "mask_weights"}, {"name": "prob_class_0"}, {"name": "prob_class_1"}, {"name": "prob_class_2"}, {"name": "prob_class_3"}, {"name": "prob_class_4"}, {"name": "prob_class_5"}, {"name": "prob_class_6"}, {"name": "prob_class_7"}, {"name": "prob_class_8"}, {"name": "prob_class_9"}, {"name": "prob_class_10"}, {"name": "prob_class_11"}, {"name": "prob_class_12"}, {"name": "prob_class_13"}, {"name": "prob_class_14"}, {"name": "prob_class_15"}, {"name": "prob_class_16"}, {"name": "prob_class_17"}, {"name": "prob_class_18"}, {"name": "prob_class_19"}, {"name": "prob_class_20"}], "eo:bands": [{"name": "mask_weights"}, {"name": "prob_class_0"}, {"name": "prob_class_1"}, {"name": "prob_class_2"}, {"name": "prob_class_3"}, {"name": "prob_class_4"}, {"name": "prob_class_5"}, {"name": "prob_class_6"}, {"name": "prob_class_7"}, {"name": "prob_class_8"}, {"name": "prob_class_9"}, {"name": "prob_class_10"}, {"name": "prob_class_11"}, {"name": "prob_class_12"}, {"name": "prob_class_13"}, {"name": "prob_class_14"}, {"name": "prob_class_15"}, {"name": "prob_class_16"}, {"name": "prob_class_17"}, {"name": "prob_class_18"}, {"name": "prob_class_19"}, {"name": "prob_class_20"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-2507181218394ddea5db66404508b78f/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a6251be271fd6bbd135cddaff3f0174d/openEO.nc?expires=1753446708", "proj:bbox": [300000, 9800000, 305000, 9805000], "proj:epsg": 3035, "proj:shape": [500, 500], "raster:bands": [{"name": "mask_weights", "statistics": {"maximum": 0.9989926815033, "mean": 0.33832602042986, "minimum": 0.018315639346838, "stddev": 0.25229339586373, "valid_percent": 100}}], "roles": ["data"], "title": "openEO.nc", "type": "application/x-netcdf"}}, "description": "Results for batch job j-2507181218394ddea5db66404508b78f", "extent": {"spatial": {"bbox": [[-124.01459266296197, 45.91202504309554, -123.9395005352897, 45.98646181534071]]}, "temporal": {"interval": [["2023-05-31T00:00:00Z", "2023-08-01T00:00:00Z"]]}}, "id": "j-2507181218394ddea5db66404508b78f", "license": "proprietary", "links": [{"href": "/eodata/Global-Mosaics/Sentinel-1/S1SAR_L3_IW_MCM/2023/06/01/Sentinel-1_IW_mosaic_2023_M06_10TDR_0_0", "rel": "derived_from", "title": "Derived from /eodata/Global-Mosaics/Sentinel-1/S1SAR_L3_IW_MCM/2023/06/01/Sentinel-1_IW_mosaic_2023_M06_10TDR_0_0", "type": "application/json"}, {"href": "/eodata/Global-Mosaics/Sentinel-1/S1SAR_L3_IW_MCM/2023/07/01/Sentinel-1_IW_mosaic_2023_M07_10TDR_0_0", "rel": "derived_from", "title": "Derived from /eodata/Global-Mosaics/Sentinel-1/S1SAR_L3_IW_MCM/2023/07/01/Sentinel-1_IW_mosaic_2023_M07_10TDR_0_0", "type": "application/json"}, {"href": "/eodata/auxdata/CopDEM/COP-DEM_GLO-30-DGED/DEM1_SAR_DGE_30_20110422T020852_20140825T021130_ADS_000000_7uxm.DEM", "rel": "derived_from", "title": "Derived from /eodata/auxdata/CopDEM/COP-DEM_GLO-30-DGED/DEM1_SAR_DGE_30_20110422T020852_20140825T021130_ADS_000000_7uxm.DEM", "type": "application/json"}, {"href": "/eodata/auxdata/CopDEM/COP-DEM_GLO-30-DGED/DEM1_SAR_DGE_30_20110422T020852_20140831T020311_ADS_000000_AZgC.DEM", "rel": "derived_from", "title": "Derived from /eodata/auxdata/CopDEM/COP-DEM_GLO-30-DGED/DEM1_SAR_DGE_30_20110422T020852_20140831T020311_ADS_000000_AZgC.DEM", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDS_20240912T224754.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDS_20240912T224754.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDS_20240911T210427.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDS_20240911T210427.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDR_20240929T132228.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDR_20240929T132228.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDS_20240911T015550.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDS_20240911T015550.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDR_20240911T015550.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDR_20240911T015550.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDS_20240929T132228.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDS_20240929T132228.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDS_20240910T111220.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDS_20240910T111220.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDR_20240913T141959.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDR_20240913T141959.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDR_20240912T224754.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDR_20240912T224754.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/14/S2A_MSIL2A_20230614T190921_N0510_R056_T10TDR_20240910T140322.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/14/S2A_MSIL2A_20230614T190921_N0510_R056_T10TDR_20240910T140322.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDR_20240911T210427.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDR_20240911T210427.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDS_20240913T141959.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDS_20240913T141959.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDR_20240911T232003.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDR_20240911T232003.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDR_20241012T054221.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDR_20241012T054221.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDS_20240911T232003.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDS_20240911T232003.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDS_20241012T054221.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDS_20241012T054221.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDR_20240910T111220.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDR_20240910T111220.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDS_20240926T101014.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDS_20240926T101014.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDR_20240926T101014.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDR_20240926T101014.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDS_20240912T224754.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDS_20240912T224754.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDS_20240911T210427.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDS_20240911T210427.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDR_20240929T132228.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDR_20240929T132228.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDS_20240911T015550.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDS_20240911T015550.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDR_20240911T015550.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/09/S2B_MSIL2A_20230709T190919_N0510_R056_T10TDR_20240911T015550.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDS_20240929T132228.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/29/S2B_MSIL2A_20230729T190919_N0510_R056_T10TDS_20240929T132228.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDR_20240913T141959.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDR_20240913T141959.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDS_20240910T111220.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDS_20240910T111220.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDR_20240911T210427.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/19/S2B_MSIL2A_20230719T190919_N0510_R056_T10TDR_20240911T210427.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/14/S2A_MSIL2A_20230614T190921_N0510_R056_T10TDR_20240910T140322.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/14/S2A_MSIL2A_20230614T190921_N0510_R056_T10TDR_20240910T140322.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDR_20240912T224754.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/04/S2A_MSIL2A_20230704T190921_N0510_R056_T10TDR_20240912T224754.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDS_20240913T141959.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/19/S2B_MSIL2A_20230619T190919_N0510_R056_T10TDS_20240913T141959.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDR_20240911T232003.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDR_20240911T232003.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDR_20241012T054221.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDR_20241012T054221.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDS_20240911T232003.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/24/S2A_MSIL2A_20230624T190921_N0510_R056_T10TDS_20240911T232003.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDS_20241012T054221.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/29/S2B_MSIL2A_20230629T190919_N0510_R056_T10TDS_20241012T054221.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDR_20240910T111220.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/06/04/S2A_MSIL2A_20230604T190921_N0510_R056_T10TDR_20240910T111220.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDS_20240926T101014.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDS_20240926T101014.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDR_20240926T101014.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2023/07/14/S2A_MSIL2A_20230714T190921_N0510_R056_T10TDR_20240926T101014.SAFE", "type": "application/json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-2507181218394ddea5db66404508b78f/results", "rel": "self", "type": "application/json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-2507181218394ddea5db66404508b78f/results/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/438f8dbbb6eb6643760945ef9f0c4c5f?expires=1753446708", "rel": "canonical", "type": "application/json"}, {"href": "http://ceos.org/ard/files/PFS/SR/v5.0/CARD4L_Product_Family_Specification_Surface_Reflectance-v5.0.pdf", "rel": "card4l-document", "type": "application/pdf"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-2507181218394ddea5db66404508b78f/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a6251be271fd6bbd135cddaff3f0174d/openEO.nc?expires=1753446708", "rel": "item", "type": "application/geo+json"}], "openeo:status": "finished", "providers": [{"description": "This data was processed on an openEO backend maintained by VITO.", "name": "VITO", "processing:expression": {"expression": {"adddimension1": {"arguments": {"data": {"from_node": "ndvi1"}, "label": "NDVI", "name": "bands", "type": "bands"}, "process_id": "add_dimension"}, "adddimension2": {"arguments": {"data": {"from_node": "reducedimension1"}, "label": "NDRE", "name": "bands", "type": "bands"}, "process_id": "add_dimension"}, "adddimension3": {"arguments": {"data": {"from_node": "reducedimension2"}, "label": "EVI", "name": "bands", "type": "bands"}, "process_id": "add_dimension"}, "aggregatetemporalperiod1": {"arguments": {"data": {"from_node": "mask1"}, "period": "month", "reducer": {"process_graph": {"mean1": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "mean", "result": true}}}}, "process_id": "aggregate_temporal_period"}, "apply1": {"arguments": {"data": {"from_node": "resamplespatial3"}, "process": {"process_graph": {"log1": {"arguments": {"base": 10, "x": {"from_parameter": "x"}}, "process_id": "log"}, "multiply1": {"arguments": {"x": 10, "y": {"from_node": "log1"}}, "process_id": "multiply", "result": true}}}}, "process_id": "apply"}, "apply2": {"arguments": {"data": {"from_node": "aggregatetemporalperiod1"}, "process": {"process_graph": {"runudf1": {"arguments": {"context": {"crs": "EPSG:3035", "east": 305000, "north": 9805000, "south": 9800000, "west": 300000}, "data": {"from_parameter": "x"}, "runtime": "Python", "udf": "import numpy as np\nimport xarray as xr\nimport logging\nfrom pyproj import Transformer\nfrom typing import Dict\n\n# Setup logging\ndef _setup_logging() -> logging.Logger:\n    logging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n    return logging.getLogger(__name__)\n\nlogger = _setup_logging()\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Constructs a lon/lat grid as a new DataArray based on the cube's spatial resolution\n    and the geographic extent provided in `context`.\n\n    Args:\n        cube (xr.DataArray): Input data cube with 'x' and 'y' dimensions.\n        context (dict): Dictionary containing 'west', 'south', 'east', 'north', and 'crs'.\n\n    Returns:\n        xr.DataArray: A new DataArray of shape (2, y, x) with bands ['lon', 'lat'].\n    \"\"\"\n\n    # Parse extent and CRS\n    try:\n        west  = float(context[\"west\"])\n        south = float(context[\"south\"])\n        east  = float(context[\"east\"])\n        north = float(context[\"north\"])\n        crs   = context[\"crs\"]\n    except KeyError as e:\n        raise ValueError(f\"Missing required context key: {e}\")\n\n    logger.info(f\"Original extent: {west}, {south} \u2192 {east}, {north} in {crs}\")\n\n    # Transform extent to EPSG:4326 if needed\n    if crs != \"EPSG:4326\":\n        transformer = Transformer.from_crs(crs, \"EPSG:4326\", always_xy=True)\n        west, south = transformer.transform(west, south)\n        east, north = transformer.transform(east, north)\n        logger.info(f\"Transformed extent to EPSG:4326: {west}, {south} \u2192 {east}, {north}\")\n\n    # Get cube dimensions\n    nx = cube.sizes[\"x\"]\n    ny = cube.sizes[\"y\"]\n\n    # Create lon/lat coordinate arrays\n    lon = np.linspace(west, east, nx, dtype=np.float32)\n    lat = np.linspace(north, south, ny, dtype=np.float32)  # north \u2192 south to match image orientation\n\n    # Generate 2D meshgrid\n    lon_grid, lat_grid = np.meshgrid(lon, lat)\n\n    logger.info(f\"Longitude range: {lon_grid.min()} to {lon_grid.max()}\")\n    logger.info(f\"Latitude range: {lat_grid.min()} to {lat_grid.max()}\")\n\n    # Build output DataArray\n    return xr.DataArray(\n        data=np.stack([lon_grid, lat_grid], axis=0),  # shape: (2, y, x)\n        dims=(\"bands\", \"y\", \"x\"),\n        coords={\n            \"bands\": [\"lon\", \"lat\"],\n            \"x\": cube.coords[\"x\"],\n            \"y\": cube.coords[\"y\"]\n        }\n    )"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply"}, "applydimension1": {"arguments": {"data": {"from_node": "mergecubes6"}, "dimension": "t", "process": {"process_graph": {"runudf2": {"arguments": {"data": {"from_parameter": "data"}, "runtime": "Python", "udf": "import numpy as np\nimport xarray as xr\nimport logging\nfrom typing import Tuple, Dict\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(message)s'  # Show only the message\n)\nlogger = logging.getLogger(__name__)\n\n# Constants\nNORM_PERCENTILES = np.array([\n    [1.7417268007636313, 2.023298706048351],\n    [1.7261204997060209, 2.038905204308012],\n    [1.6798346251414997, 2.179592821212937],\n    [2.3828939530384052, 2.7578332604178284],\n    [1.7417268007636313, 2.023298706048351],\n    [1.7417268007636313, 2.023298706048351],\n    [1.7417268007636313, 2.023298706048351],\n    [1.7417268007636313, 2.023298706048351],\n    [1.7417268007636313, 2.023298706048351]\n], dtype=np.float32)\n\nEXPECTED_BANDS = [\n    \"B02\", \"B03\", \"B04\", \"B05\", \"B06\", \"B07\", \"B08\", \"B11\", \"B12\",\n    \"NDVI\", \"NDRE\", \"EVI\",  # Vegetation indices\n    \"VV\", \"VH\",             # Radar\n    \"DEM\", \"lon\", \"lat\"     # Topography/coordinates\n]\n\n# --- Normalization helpers ---\n\ndef normalise_vv(raster: np.ndarray) -> np.ndarray:\n    return np.clip((raster + 25) / 25, 0, 1).astype(np.float32)\n\ndef normalise_vh(raster: np.ndarray) -> np.ndarray:\n    return np.clip((raster + 30) / 25, 0, 1).astype(np.float32)\n\ndef normalise_longitude(raster: np.ndarray) -> np.ndarray:\n    return np.clip((raster + 180) / 360, 0, 1).astype(np.float32)\n\ndef normalise_latitude(raster: np.ndarray) -> np.ndarray:\n    return np.clip((raster + 60) / 120, 0, 1).astype(np.float32)\n\ndef normalise_altitude(raster: np.ndarray) -> np.ndarray:\n    return np.clip((raster + 400) / 8400, 0, 1).astype(np.float32)\n\ndef normalise_vegetation(raster: np.ndarray) -> np.ndarray:\n    return np.clip((raster + 1) / 2, 0, 1).astype(np.float32)\n\ndef norm_optical(image: np.ndarray) -> np.ndarray:\n    min_values = NORM_PERCENTILES[:, 0].reshape(9, 1, 1)\n    scale_values = NORM_PERCENTILES[:, 1].reshape(9, 1, 1)\n\n    image = np.log(image * 0.005 + 1)\n    image = (image - min_values) / scale_values\n    image = np.exp(image * 5 - 1)\n    return (image / (image + 1)).astype(np.float32)\n\n# --- Core logic ---\n\ndef validate_and_reorder_bands(\n    data: xr.DataArray\n) -> Tuple[xr.DataArray, Dict[str, int]]:\n    \"\"\"\n    Ensure the input DataArray has all EXPECTED_BANDS in the correct order.\n\n    Returns:\n        Tuple of (reordered data, band name to index mapping).\n        Raises ValueError if bands are missing.\n    \"\"\"\n    current = list(data.coords[\"bands\"].values)\n\n    if current != EXPECTED_BANDS:\n        try:\n            data = data.sel(bands=EXPECTED_BANDS)\n            logger.info(f\"Reordered bands from {current} to {EXPECTED_BANDS}\")\n        except KeyError:\n            missing = sorted(set(EXPECTED_BANDS) - set(current))\n            logger.error(f\"Missing required band(s): {missing}. Available: {current}\")\n            raise ValueError(f\"Missing required band(s): {missing}\")\n\n    band_names = list(data.coords[\"bands\"].values)\n    try:\n        band_indices = {b: band_names.index(b) for b in EXPECTED_BANDS}\n        logger.info(f\"Band indices mapped: {band_indices}\")\n    except ValueError:\n        logger.error(f\"Failed to map indices. Bands present: {band_names}\")\n        raise ValueError(f\"Band order mismatch. Expected: {EXPECTED_BANDS}, Got: {band_names}\")\n\n    return data, band_indices\n\ndef apply_datacube(cube: xr.DataArray, context: dict) -> xr.DataArray:\n    \"\"\"\n    Normalize input datacube for inference:\n    - Optical bands (first 9): via log-transform then sigmoid-like scale\n    - Others (VV, VH, NDVI, NDRE, EVI, DEM, lon, lat): via fixed min/max scalings\n\n    Args:\n        cube (xr.DataArray): Input cube with dims (bands, y, x, t)\n        context (dict): Unused, placeholder for UDF interface\n\n    Returns:\n        Normalized xr.DataArray with shape (15, y, x, t)\n    \"\"\"\n    cube = cube.transpose(\"bands\", \"y\", \"x\", \"t\")\n    logger.info(f\"Received data with shape: {cube.shape} and dims: {cube.dims}\")\n\n    reordered, band_idx = validate_and_reorder_bands(cube)\n    vals = reordered.values\n\n    # 1) Optical bands normalization\n    optical = vals[:9, ...]\n    mins = NORM_PERCENTILES[:, 0].reshape(9, 1, 1, 1)\n    scales = NORM_PERCENTILES[:, 1].reshape(9, 1, 1, 1)\n\n    normed_opt = np.log(optical * 0.005 + 1)\n    normed_opt = (normed_opt - mins) / scales\n    normed_opt = np.exp(normed_opt * 5 - 1)\n    normed_opt = (normed_opt / (normed_opt + 1)).astype(np.float32)\n\n    # 2) Scalar band normalization\n    ndvi = normalise_vegetation(vals[band_idx[\"NDVI\"], ...])\n    ndre = normalise_vegetation(vals[band_idx[\"NDRE\"], ...])\n    evi = normalise_vegetation(vals[band_idx[\"EVI\"], ...])\n    vv   = normalise_vv(vals[band_idx[\"VV\"], ...])\n    vh   = normalise_vh(vals[band_idx[\"VH\"], ...])\n    dem  = normalise_altitude(vals[band_idx[\"DEM\"], ...])\n    lon  = normalise_longitude(vals[band_idx[\"lon\"], ...])\n    lat  = normalise_latitude(vals[band_idx[\"lat\"], ...])\n\n    # 3) Concatenate all normalized bands\n    output = np.concatenate(\n        [normed_opt, ndvi[None], ndre[None], evi[None], vv[None], vh[None], dem[None], lon[None], lat[None]],\n        axis=0\n    )\n\n    return xr.DataArray(\n        output,\n        dims=(\"bands\", \"y\", \"x\", \"t\"),\n        coords={**reordered.coords, \"bands\": EXPECTED_BANDS}\n    )\n\n\n    \n\n    \n\n"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applyneighborhood1": {"arguments": {"data": {"from_node": "applydimension1"}, "overlap": [{"dimension": "x", "unit": "px", "value": 0}, {"dimension": "y", "unit": "px", "value": 0}], "process": {"process_graph": {"runudf3": {"arguments": {"data": {"from_parameter": "data"}, "runtime": "Python", "udf": "import sys\nimport functools\nimport numpy as np\nimport xarray as xr\nimport logging\nfrom typing import Dict, Tuple\n\n\n\n# Setup logger\ndef _setup_logging():\n    logging.basicConfig(level=logging.INFO)\n    return logging.getLogger(__name__)\n\nlogger = _setup_logging()\n\n# Add ONNX paths\nsys.path.append(\"onnx_deps\")\nsys.path.append(\"onnx_models\")\nimport onnxruntime as ort\n\n# Constants for sanitization\n_INF_REPLACEMENT = 1e6\n_NEG_INF_REPLACEMENT = -1e6\n\n@functools.lru_cache(maxsize=1)\ndef _load_ort_session(model_name: str) -> ort.InferenceSession:\n    \"\"\"Loads an ONNX model and returns a cached ONNX runtime session.\"\"\"\n    return ort.InferenceSession(f\"onnx_models/{model_name}\")\n\n@functools.lru_cache(maxsize=1)\ndef build_gaussian_mask(height: int, width: int, sigma: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Builds a 2D Gaussian mask for CNN-style patch blending.\n    \n    sigma: relative spread (e.g., 0.125 \u2192 ~1/8th of patch size)\n    \"\"\"\n    y = np.linspace(-1, 1, height)\n    x = np.linspace(-1, 1, width)\n    xx, yy = np.meshgrid(x, y)\n    gaussian = np.exp(-0.5 * ((xx**2 + yy**2) / sigma**2))\n    return gaussian.astype(np.float32)\n\n\n\ndef preprocess_image(cube: xr.DataArray) -> Tuple[np.ndarray, Dict[str, xr.Coordinate], np.ndarray]:\n    \"\"\"\n    Prepare the input cube for inference:\n      - Transpose to (y, x, bands)\n      - Sanitize NaN/Inf\n      - Return batch tensor, coords, and invalid-value mask\n    \"\"\"\n    # Reorder dims\n    reordered = cube.transpose(\"y\", \"x\", \"bands\")\n    values = reordered.values.astype(np.float32)\n\n    # Mask invalid entries\n    mask_invalid = ~np.isfinite(values)\n\n    # Replace NaN with 0, inf with large sentinel\n    sanitized = np.where(np.isnan(values), 0.0, values)\n    sanitized = np.where(np.isposinf(sanitized), _INF_REPLACEMENT, sanitized)\n    sanitized = np.where(np.isneginf(sanitized), _NEG_INF_REPLACEMENT, sanitized)\n\n    # Add batch dimension\n    input_tensor = sanitized[None, ...]\n    logger.info(f\"Preprocessed tensor shape={input_tensor.shape}\")\n    return input_tensor, reordered.coords, mask_invalid\n\n\ndef run_inference(\n    session: ort.InferenceSession,\n    input_name: str,\n    input_tensor: np.ndarray\n) -> np.ndarray:\n    \"\"\"Run ONNX session and remove batch dimension from output.\"\"\"\n    outputs = session.run(None, {input_name: input_tensor})\n    pred = np.squeeze(outputs[0], axis=0)\n    logger.info(f\"Inference output shape={pred.shape}\")\n    return pred\n\n\ndef postprocess_output(\n    pred: np.ndarray,\n    coords: Dict[str, xr.Coordinate],\n    mask_invalid: np.ndarray\n) -> xr.DataArray:\n    \"\"\"\n    Combine class predictions and probabilities into DataArray,\n    restoring NaNs for originally invalid pixels.\n    \"\"\"\n    # Remove background class (class 0)\n    scores = pred[..., 1:].astype(np.float32)\n\n    # Normalize probabilities across class axis\n    score_sums = np.sum(scores, axis=-1, keepdims=True)\n    normalized_scores = np.divide(\n        scores,\n        score_sums,\n        out=np.zeros_like(scores),\n        where=score_sums != 0\n    )\n\n    normalized_scores *= 100.0\n\n    gausian_mask = build_gaussian_mask(normalized_scores.shape[0], normalized_scores.shape[1])\n    # Apply to each class score (broadcast along last dimension)\n    weighted_scores = normalized_scores * gausian_mask[..., None]\n\n    # Restore invalid pixels as NaN\n    invalid_any = np.any(mask_invalid, axis=-1)\n    weighted_scores[invalid_any] = 101 #TODO which value to set?\n\n    output_arr = np.concatenate([gausian_mask[..., None], weighted_scores], axis=-1)\n\n    # Build DataArray\n    y_coords = coords[\"y\"]\n    x_coords = coords[\"x\"]\n    band_coords = np.arange(output_arr.shape[-1])\n\n    return xr.DataArray(\n        output_arr,\n        dims=(\"y\", \"x\", \"bands\"),\n        coords={\"y\": y_coords, \"x\": x_coords, \"bands\": band_coords}\n    )\n\n\ndef apply_model(\n    cube: xr.DataArray,\n    model_path: str\n) -> xr.DataArray:\n    \"\"\"\n    Full inference pipeline: preprocess, infer, postprocess.\n    \"\"\"\n    input_tensor, coords, mask_invalid = preprocess_image(cube)\n    session = _load_ort_session(model_path)\n    input_name = session.get_inputs()[0].name\n    raw_pred = run_inference(session, input_name, input_tensor)\n    \n    result = postprocess_output(raw_pred, coords, mask_invalid)\n    logger.info(f\"apply_model result shape={result.shape}\")\n    return result\n\ndef _pad_to_64(arr: np.ndarray, pad_value: float = np.nan) -> Tuple[np.ndarray, Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Given an array `arr` of shape (y_sub, x_sub, bands), where y_sub<=64 and x_sub<=64,\n    pad it to exactly (64, 64, bands) by adding `pad_value` on bottom/right.\n    Returns:\n      - padded array of shape (64,64,bands)\n      - (y_pad_before, y_pad_after)  \u2192 e.g. (0, 64-y_sub)\n      - (x_pad_before, x_pad_after)  \u2192 e.g. (0, 64-x_sub)\n    \"\"\"\n    y_sub, x_sub, bands = arr.shape\n    pad_y = 64 - y_sub\n    pad_x = 64 - x_sub\n    pad_width = [(0, pad_y), (0, pad_x), (0, 0)]  # pad in bottom/right only\n    padded = np.pad(arr, pad_width, mode=\"constant\", constant_values=pad_value)\n    return padded, (0, pad_y), (0, pad_x)\n\ndef _unpad_from_64(\n    result_patch: np.ndarray,\n    y_pad: Tuple[int, int],\n    x_pad: Tuple[int, int]\n) -> np.ndarray:\n    \"\"\"\n    Given `result_patch` of shape (64,64,bands_out) and the paddings\n    y_pad=(y_before,y_after), x_pad=(x_before,x_after), slice away the padded\n    rows/columns and return an array of shape (64 - (y_before+y_after),\n    64 - (x_before+x_after), bands_out).\n    \"\"\"\n    y_before, y_after = y_pad\n    x_before, x_after = x_pad\n    y_stop = 64 - y_after\n    x_stop = 64 - x_after\n    return result_patch[y_before:y_stop, x_before:x_stop, :]\n\n\ndef apply_model_on_tiles(\n    cube: xr.DataArray,\n    model_path: str,\n    tile_size: int = 64\n) -> xr.DataArray:\n    \"\"\"\n    Given a single\u2010timestep cube of shape (y_full, x_full, bands),\n    break it into non\u2010overlapping tile_size\u00d7tile_size patches (padding edges),\n    call apply_model() on each 64\u00d764 patch, then unpad & stitch back.\n\n    Returns: one DataArray of shape (y_full, x_full, bands_out).\n    \"\"\"\n    y_full = cube.sizes[\"y\"]\n    x_full = cube.sizes[\"x\"]\n\n    # How many tiles along y and x?\n    ny = int(np.ceil(y_full / tile_size))\n    nx = int(np.ceil(x_full / tile_size))\n\n    # Slice y=[0:64], x=[0:64] (clamped if smaller)\n    top = cube.isel(\n        y=slice(0, min(tile_size, y_full)),\n        x=slice(0, min(tile_size, x_full))\n    )\n    arr0 = top.transpose(\"y\", \"x\", \"bands\").values.astype(np.float32)\n    padded0, y_pad0, x_pad0 = _pad_to_64(arr0, pad_value=np.nan)\n\n    # Wrap into a DataArray so apply_model can run\n    da0 = xr.DataArray(\n        padded0,\n        dims=(\"y\", \"x\", \"bands\"),\n        coords={\n            \"y\": np.arange(tile_size),\n            \"x\": np.arange(tile_size),\n            \"bands\": top.coords[\"bands\"]\n        }\n    )\n    out0 = apply_model(da0, model_path)\n    bands_out = out0.sizes[\"bands\"]\n\n    # Prepare a big container for the stitched result\n    stitched = np.full((y_full, x_full, bands_out), np.nan, dtype=np.float32)\n\n\n    for iy in range(ny):\n        for ix in range(nx):\n            y0 = iy * tile_size\n            x0 = ix * tile_size\n            y1 = min(y0 + tile_size, y_full)\n            x1 = min(x0 + tile_size, x_full)\n\n            # Extract that sub\u2010window\n            sub = cube.isel(\n                y=slice(y0, y1),\n                x=slice(x0, x1)\n            )\n            arr_sub = sub.transpose(\"y\", \"x\", \"bands\").values.astype(np.float32)\n\n            # Pad if needed (only on bottom/right)\n            padded, y_pad, x_pad = _pad_to_64(arr_sub, pad_value=np.nan)\n\n            # Wrap padded into DataArray for apply_model\n            da_pad = xr.DataArray(\n                padded,\n                dims=(\"y\", \"x\", \"bands\"),\n                coords={\n                    \"y\": np.arange(tile_size),\n                    \"x\": np.arange(tile_size),\n                    \"bands\": sub.coords[\"bands\"]\n                }\n            )\n\n            # Run the full preprocess \u2192 inference \u2192 postprocess for this tile\n            out_patch = apply_model(da_pad, model_path)  \n            # out_patch is (64,64,bands_out)\n\n            # Unpad: remove any rows/cols that we added\n            arr_out_patch = out_patch.values  # (64,64,bands_out)\n            unpadded = _unpad_from_64(arr_out_patch, y_pad, x_pad)\n            # Now unpadded.shape == (y1-y0, x1-x0, bands_out)\n\n            # Write into the stitched array\n            stitched[y0:y1, x0:x1, :] = unpadded\n\n    return xr.DataArray(\n        stitched,\n        dims=(\"y\", \"x\", \"bands\"),\n        coords={\n            \"y\": cube.coords[\"y\"].values,\n            \"x\": cube.coords[\"x\"].values,\n            \"bands\": np.arange(bands_out)\n        }\n    )\n\n\ndef apply_datacube(cube: xr.DataArray, context: dict) -> xr.DataArray:\n    \"\"\"\n    Apply ONNX model per timestep in the datacube.\n    \"\"\"\n    logger.info(f\"apply_datacube received shape={cube.shape}, dims={cube.dims}\")\n    cube = cube.transpose('y', 'x', 'bands', 't')\n\n    if 't' in cube.dims:\n        logger.info(\"Applying model per timestep via groupby-map.\")\n        return cube.groupby('t').map(lambda da: apply_model_on_tiles(da, \"WAC_model_hansvrp.onnx\"))\n    else:\n        logger.info(\"Single timestep: applying model once.\")\n        return apply_model_on_tiles(cube, \"WAC_model_hansvrp.onnx\")"}, "process_id": "run_udf", "result": true}}}, "size": [{"dimension": "x", "unit": "px", "value": 64}, {"dimension": "y", "unit": "px", "value": 64}]}, "process_id": "apply_neighborhood"}, "loadcollection1": {"arguments": {"bands": ["B02", "B03", "B04", "B05", "B06", "B07", "B08", "B11", "B12"], "id": "SENTINEL2_L2A", "properties": {"eo:cloud_cover": {"process_graph": {"lte1": {"arguments": {"x": {"from_parameter": "value"}, "y": 85}, "process_id": "lte", "result": true}}}}, "spatial_extent": {"crs": "EPSG:3035", "east": 305000, "north": 9805000, "south": 9800000, "west": 300000}, "temporal_extent": ["2023-06-01", "2023-08-01"]}, "process_id": "load_collection"}, "loadcollection2": {"arguments": {"bands": ["SCL"], "id": "SENTINEL2_L2A", "properties": {"eo:cloud_cover": {"process_graph": {"lte2": {"arguments": {"x": {"from_parameter": "value"}, "y": 85}, "process_id": "lte", "result": true}}}}, "spatial_extent": {"crs": "EPSG:3035", "east": 305000, "north": 9805000, "south": 9800000, "west": 300000}, "temporal_extent": ["2023-06-01", "2023-08-01"]}, "process_id": "load_collection"}, "loadcollection3": {"arguments": {"bands": ["VV", "VH"], "id": "SENTINEL1_GLOBAL_MOSAICS", "spatial_extent": {"crs": "EPSG:3035", "east": 305000, "north": 9805000, "south": 9800000, "west": 300000}, "temporal_extent": ["2023-05-31", "2023-08-01"]}, "process_id": "load_collection"}, "loadcollection4": {"arguments": {"id": "COPERNICUS_30", "spatial_extent": {"crs": "EPSG:3035", "east": 305000, "north": 9805000, "south": 9800000, "west": 300000}, "temporal_extent": null}, "process_id": "load_collection"}, "mask1": {"arguments": {"data": {"from_node": "resamplespatial1"}, "mask": {"from_node": "toscldilationmask1"}}, "process_id": "mask"}, "mergecubes1": {"arguments": {"cube1": {"from_node": "aggregatetemporalperiod1"}, "cube2": {"from_node": "apply1"}}, "process_id": "merge_cubes"}, "mergecubes2": {"arguments": {"cube1": {"from_node": "mergecubes1"}, "cube2": {"from_node": "adddimension1"}}, "process_id": "merge_cubes"}, "mergecubes3": {"arguments": {"cube1": {"from_node": "mergecubes2"}, "cube2": {"from_node": "adddimension2"}}, "process_id": "merge_cubes"}, "mergecubes4": {"arguments": {"cube1": {"from_node": "mergecubes3"}, "cube2": {"from_node": "adddimension3"}}, "process_id": "merge_cubes"}, "mergecubes5": {"arguments": {"cube1": {"from_node": "mergecubes4"}, "cube2": {"from_node": "reducedimension3"}}, "process_id": "merge_cubes"}, "mergecubes6": {"arguments": {"cube1": {"from_node": "mergecubes5"}, "cube2": {"from_node": "renamelabels1"}}, "process_id": "merge_cubes"}, "ndvi1": {"arguments": {"data": {"from_node": "aggregatetemporalperiod1"}, "nir": "B08", "red": "B04"}, "process_id": "ndvi"}, "reducedimension1": {"arguments": {"data": {"from_node": "aggregatetemporalperiod1"}, "dimension": "bands", "reducer": {"process_graph": {"add1": {"arguments": {"x": {"from_node": "arrayelement3"}, "y": {"from_node": "arrayelement4"}}, "process_id": "add"}, "arrayelement1": {"arguments": {"data": {"from_parameter": "data"}, "index": 6}, "process_id": "array_element"}, "arrayelement2": {"arguments": {"data": {"from_parameter": "data"}, "index": 3}, "process_id": "array_element"}, "arrayelement3": {"arguments": {"data": {"from_parameter": "data"}, "index": 6}, "process_id": "array_element"}, "arrayelement4": {"arguments": {"data": {"from_parameter": "data"}, "index": 3}, "process_id": "array_element"}, "divide1": {"arguments": {"x": {"from_node": "subtract1"}, "y": {"from_node": "add1"}}, "process_id": "divide", "result": true}, "subtract1": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}}}}, "process_id": "reduce_dimension"}, "reducedimension2": {"arguments": {"data": {"from_node": "aggregatetemporalperiod1"}, "dimension": "bands", "reducer": {"process_graph": {"add2": {"arguments": {"x": {"from_node": "arrayelement7"}, "y": {"from_node": "multiply3"}}, "process_id": "add"}, "add3": {"arguments": {"x": {"from_node": "subtract3"}, "y": 1}, "process_id": "add"}, "arrayelement5": {"arguments": {"data": {"from_parameter": "data"}, "index": 6}, "process_id": "array_element"}, "arrayelement6": {"arguments": {"data": {"from_parameter": "data"}, "index": 2}, "process_id": "array_element"}, "arrayelement7": {"arguments": {"data": {"from_parameter": "data"}, "index": 6}, "process_id": "array_element"}, "arrayelement8": {"arguments": {"data": {"from_parameter": "data"}, "index": 2}, "process_id": "array_element"}, "arrayelement9": {"arguments": {"data": {"from_parameter": "data"}, "index": 0}, "process_id": "array_element"}, "divide2": {"arguments": {"x": {"from_node": "multiply2"}, "y": {"from_node": "add3"}}, "process_id": "divide", "result": true}, "multiply2": {"arguments": {"x": 2.5, "y": {"from_node": "subtract2"}}, "process_id": "multiply"}, "multiply3": {"arguments": {"x": 6, "y": {"from_node": "arrayelement8"}}, "process_id": "multiply"}, "multiply4": {"arguments": {"x": 7.5, "y": {"from_node": "arrayelement9"}}, "process_id": "multiply"}, "subtract2": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement6"}}, "process_id": "subtract"}, "subtract3": {"arguments": {"x": {"from_node": "add2"}, "y": {"from_node": "multiply4"}}, "process_id": "subtract"}}}}, "process_id": "reduce_dimension"}, "reducedimension3": {"arguments": {"data": {"from_node": "resamplespatial4"}, "dimension": "t", "reducer": {"process_graph": {"mean2": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "mean", "result": true}}}}, "process_id": "reduce_dimension"}, "renamelabels1": {"arguments": {"data": {"from_node": "resamplespatial5"}, "dimension": "bands", "target": ["lon", "lat"]}, "process_id": "rename_labels"}, "renamelabels2": {"arguments": {"data": {"from_node": "applyneighborhood1"}, "dimension": "bands", "target": ["mask_weights", "prob_class_0", "prob_class_1", "prob_class_2", "prob_class_3", "prob_class_4", "prob_class_5", "prob_class_6", "prob_class_7", "prob_class_8", "prob_class_9", "prob_class_10", "prob_class_11", "prob_class_12", "prob_class_13", "prob_class_14", "prob_class_15", "prob_class_16", "prob_class_17", "prob_class_18", "prob_class_19", "prob_class_20"]}, "process_id": "rename_labels"}, "resamplespatial1": {"arguments": {"align": "upper-left", "data": {"from_node": "loadcollection1"}, "method": "near", "projection": "EPSG:3035", "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial2": {"arguments": {"align": "upper-left", "data": {"from_node": "loadcollection2"}, "method": "near", "projection": "EPSG:3035", "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial3": {"arguments": {"align": "upper-left", "data": {"from_node": "loadcollection3"}, "method": "near", "projection": "EPSG:3035", "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial4": {"arguments": {"align": "upper-left", "data": {"from_node": "loadcollection4"}, "method": "bilinear", "projection": "EPSG:3035", "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial5": {"arguments": {"align": "upper-left", "data": {"from_node": "apply2"}, "method": "near", "projection": "EPSG:3035", "resolution": 10}, "process_id": "resample_spatial"}, "saveresult1": {"arguments": {"data": {"from_node": "renamelabels2"}, "format": "netCDF", "options": {}}, "process_id": "save_result", "result": true}, "toscldilationmask1": {"arguments": {"data": {"from_node": "resamplespatial2"}}, "process_id": "to_scl_dilation_mask"}}, "format": "openeo"}, "processing:facility": "openEO Geotrellis backend", "processing:software": {"Geotrellis backend": "0.66.0a10"}, "roles": ["processor"]}], "stac_extensions": ["https://stac-extensions.github.io/eo/v1.1.0/schema.json", "https://stac-extensions.github.io/file/v2.1.0/schema.json", "https://stac-extensions.github.io/processing/v1.1.0/schema.json", "https://stac-extensions.github.io/projection/v1.1.0/schema.json"], "stac_version": "1.0.0", "summaries": {}, "type": "Collection"}